#!/usr/bin/env node

import fs from 'node:fs/promises'
import path from 'node:path'
import { fileURLToPath } from 'node:url'
import crypto from 'node:crypto'

const __dirname = path.dirname(fileURLToPath(import.meta.url))
const ROOT = path.join(__dirname, '..', '..')

function parseArgs(argv) {
  const args = [...argv]
  let configPath = path.join(ROOT, 'data', 'models.json')
  const configIndex = args.indexOf('--config')
  if (configIndex !== -1) {
    const value = args[configIndex + 1]
    if (!value) {
      throw new Error('--config requires a file path')
    }
    configPath = path.resolve(value)
    args.splice(configIndex, 2)
  }
  let outputDir = path.join(ROOT, 'data', 'models')
  const outputIndex = args.indexOf('--output')
  if (outputIndex !== -1) {
    const value = args[outputIndex + 1]
    if (!value) {
      throw new Error('--output requires a directory path')
    }
    outputDir = path.resolve(value)
    args.splice(outputIndex, 2)
  }
  return { configPath, outputDir }
}

async function ensureConfig(configPath) {
  try {
    const raw = await fs.readFile(configPath, 'utf8')
    return JSON.parse(raw)
  } catch (error) {
    if (error.code === 'ENOENT') {
      await fs.mkdir(path.dirname(configPath), { recursive: true })
      const payload = { models: [] }
      await fs.writeFile(configPath, JSON.stringify(payload, null, 2), 'utf8')
      console.warn(`[ai:prepare] created default model config at ${configPath}`)
      return payload
    }
    throw error
  }
}

async function ensureDir(target) {
  await fs.mkdir(target, { recursive: true })
}

async function copyIfNeeded(source, target) {
  if (!source) return false
  const resolvedSource = path.resolve(source)
  const resolvedTarget = path.resolve(target)
  if (resolvedSource === resolvedTarget) {
    return false
  }
  await ensureDir(path.dirname(resolvedTarget))
  await fs.copyFile(resolvedSource, resolvedTarget)
  return true
}

async function createPlaceholder(target, model) {
  const resolvedTarget = path.resolve(target)
  await ensureDir(path.dirname(resolvedTarget))
  const payload = {
    id: model.id,
    adapter: model.adapter || 'unknown',
    generatedAt: new Date().toISOString(),
    note: 'placeholder file generated by ai:prepare'
  }
  await fs.writeFile(resolvedTarget, JSON.stringify(payload, null, 2), 'utf8')
  return true
}

async function verifyChecksum(filePath, checksum) {
  if (!checksum) return true
  const [algorithm, expected] = checksum.split(':')
  if (!algorithm || !expected) {
    throw new Error(`invalid checksum format for ${filePath}`)
  }
  const normalizedAlgorithm = algorithm.toLowerCase()
  if (normalizedAlgorithm !== 'sha256') {
    throw new Error(`unsupported checksum algorithm ${algorithm} for ${filePath}`)
  }
  const hash = crypto.createHash('sha256')
  const file = await fs.open(filePath, 'r')
  try {
    const stream = file.createReadStream()
    for await (const chunk of stream) {
      hash.update(chunk)
    }
  } finally {
    await file.close()
  }
  const digest = hash.digest('hex')
  if (digest !== expected.toLowerCase()) {
    throw new Error(`checksum mismatch for ${filePath}: expected ${expected}, got ${digest}`)
  }
  return true
}

function resolveTargetPath(model, outputDir) {
  if (model.target) {
    return path.isAbsolute(model.target) ? model.target : path.join(ROOT, model.target)
  }
  const fileName = model.fileName || `${model.id}.bin`
  return path.join(outputDir, model.id || fileName.replace(/\.\w+$/, ''), fileName)
}

async function processModel(model, options) {
  if (!model || typeof model !== 'object') {
    return { id: 'unknown', status: 'skipped', reason: 'invalid-model-entry' }
  }
  const target = resolveTargetPath(model, options.outputDir)
  const source = model.source ? (path.isAbsolute(model.source) ? model.source : path.join(ROOT, model.source)) : null
  const summary = { id: model.id || target, target }
  try {
    let changed = false
    if (source) {
      await copyIfNeeded(source, target)
      changed = true
      summary.source = source
    } else {
      const exists = await fs.access(target).then(() => true).catch(() => false)
      if (!exists) {
        await createPlaceholder(target, model)
        changed = true
      }
    }
    await verifyChecksum(target, model.checksum)
    summary.status = changed ? 'prepared' : 'cached'
    return summary
  } catch (error) {
    summary.status = 'failed'
    summary.error = error.message || String(error)
    return summary
  }
}

async function main() {
  const { configPath, outputDir } = parseArgs(process.argv.slice(2))
  const config = await ensureConfig(configPath)
  if (!Array.isArray(config.models)) {
    throw new Error(`invalid model config: ${configPath}`)
  }
  await ensureDir(outputDir)
  const results = []
  for (const model of config.models) {
    const result = await processModel(model, { outputDir })
    results.push(result)
    if (result.status === 'failed') {
      console.error(`[ai:prepare] ${result.id} failed: ${result.error}`)
    } else {
      const marker = result.status === 'prepared' ? 'prepared' : 'cached'
      console.log(`[ai:prepare] ${result.id} ${marker} -> ${result.target}`)
    }
  }
  const failures = results.filter(item => item.status === 'failed')
  if (failures.length) {
    throw new Error(`ai:prepare failed for ${failures.length} model(s)`)
  }
  console.log(`[ai:prepare] completed ${results.length} model(s) using config ${configPath}`)
}

main().catch(error => {
  console.error('[ai:prepare] error:', error.message || error)
  process.exit(1)
})
